# 合并配置

配置的合并策略比较简单大概分为以下几点：

1. 标准化 props、Inject、Directives
   - props --> array
   - 循环数组 --> 标准化key 和 res[name] = { type: null }
   - props --> obj
   - 枚举obj --> 标准化key --> val是Obj就返回不是的 返回 { type: val }
   - props --> 都不是报错
   - Inject -->  array --> 将数组改为形如{from:val} 的对象
   - Inject -->  obj -->  return val  isObj ? extend({ from: key }, val) : { from: val }
   - Inject --> 都不是报错
   - Directives --> 枚举 --> def = dirs[key]如果是一个函数dirs[key] = { bind: def, update: def }
2. 如果child有继承的属性那么就递归调用mergeOptions进行合并，并赋值到parent
3. 如果child有mixins 循环数组调用mergeOptions进行合并，并赋值到parent
4. 枚举parent 、child 执行不同的key的函数合并策略，合并到options上并返回：如下
5. component、directive、filter --> 先在res的原型上创建父的属性、方法  --> 有child浅拷贝无child直接返回。
6. provide、data 合并
   - 调用mergeDataOrFn进行合并
   - 判断完vm、child、parent后调用mergeData进行合并
   - 枚举from -->  !hasOwn(to, key) --> 设置响应式 --> 否则如果toVal、fromVal都是Obj -->  递归mergeData合并
7. props、methods、inject、computed --> 实际上 就是复制child和parent的属性
8. 钩子函数 --> mergeHook --> 子父存在相加  | 父不存在 、子强制为数组返回
9. watch
   - 进行 nativeWatch、child、parent的检测
   - 检测通过 --> 拷贝parent
   - 枚举子 -->  有父转数组 --> 再和子合并或者将子转化为数组
   - 返回结果
10. 未知选项 --> defaultStrat --> 有子拿子、无子拿父。