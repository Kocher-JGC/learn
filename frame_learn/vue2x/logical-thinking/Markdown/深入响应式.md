在理解响应式之前你需要对以下理解

1. new Vue --> mergeOpts 、init--> $mount --> mountComponent --> new Watcher --> render() --> update0 --> patch --> createElm渲染真实的DOM
   1. 合并配置都干了些为什么把你传入的配置合并成什么样子了
   2. init干了些什么生成了什么属性、（注意initData中如何对【data、props、methods、computed、watch】的处理） --> observe() 干了些什么
   3. _render 中如何生成VNode
   4. patch如何将VNode 里面 数据+属性+tag 渲染成真实的DOM



对整个渲染的流程熟悉了后，就需要理解

1. watcher 类、Dep 类、Observer类、以及很重要的defineReactive方法
2. 理解他们直接如何进行以来收集和 以及如何触发更新渲染DOM。
   1. 通过理解语法糖的定义理解运行流程
   2. 通过理解queueWatcher、flushSchedulerQueue、以及上面提到的类和方法 理解整个依赖的收集和更新的过程 --> 最终触发更新
3. 大体流程理解完后，分小块深入理解【data、props、methods、computed、watch】
4. 总而言之。学习重点在observer文件夹中的所有js

> 因为之前整个流程重点分析过所以例子中部分流程会简化
#简单开始 [simpleData（data、methods）](../HTML/simpleData.html)

## mergeOpts和initData

### mergeOpts

1. mergeMethods -->   无父直接返回传入的method
2. dataMethods --> 返回 mergedInstanceDataFn函数                                                                    

### initData

1. initMethods--> 调用bind函数修改函数调用的指针

2. initData --> getData() [调用merge时候返回的函数]--> 拿到返回值赋值到 vm.$options.data 

   -  循环data的key --> 检查可用性 如果是普通类型 调用 proxy进行代理访问

   - 调用observe 对data  进行 new Observer() --> 把所有的对象转换为响应式对象 -->

     - > 1、如果是数组则使用**原型方式修改或使用复制方式**修改（修改原数组的方法来实现 响应式） --> 再调用this.observeArray() -->  循环对每个元素进行observe定义
       >
       > 2、直接调用this.walk(value)  --> 枚举每个key 来进行defineReactive（）
       >
       > ** 注意**数组和defineReactive 来进行对observe的调用**（递归的设置响应语法糖） （小心被绕晕了）

     - 赋值this.value = 传入的data

     - this.Dep =  new Dep() (依赖收集的类)

     - def() --> 向data中加入__ob\_\_属性并且可枚举性为false

     - 调用 this.walk(obj) --> 循环obj的key 调用defineReactive（定义对应key的响应的语法糖） --> 经过检查后 --> **如果发现obj[key]是一个对象（满足typeof === 'object' 即可）递归调用observe**进行 new Observer或者返回已经实例的ob

     - 最后返回一个最大的 Observer

## $mount --> mountComponent

1. callHook(vm, 'beforeMount');  --> 组装 updateComponent函数
2. new Watcher（） --> watcher.get()
   - push当前Watcher --> targetStack
   - this.getter.call(vm,vm) --> updateComponent() -->

### updateComponent() -->

```javascript
(function anonymous() {
  with(this){
    return _c('div',{attrs:{"id":"app"}},[
      _v("\n    "+_s(msg)+"\n    "),
      _c('hr'),_v("\n    "+_s(info)+"\n    "),
      _c('hr'),_v(" "),
      _c('button',{on:{"click":function($event){growUp(1)}}},[_v("点我长大一岁")]),
      _v(" "),
      _c('button',{on:{"click":function($event){addArrayVal()}}}[_v("addArrayVal")]),
      _v(" "),
      _c('button',{on:{"click":function($event){addObjVal()}}},[_v("addObjVal")])])
  }
})
```

#### render 

1. _v --> 创建text的VNode 跳过
2. _s --> 实际上是shared/util.js 的toString方法 --> return 格式化好的字符串
3. _c('hr') , _c('button') -->  _createElement --> 返回渲染浏览器内置元素的VNode

#### update --> patch 

> update 存储（ prevEl 、prevVnode 、 preActiveInstance ）

patch -->

1.  oldVnode = emptyNodeAt(oldVnode); --> 创建了一个空的DOM VNode 用于替换原来的DOM （此后以 ①为别名）
2. createElm --> 调用原生方法创建真实DOM  = vnode.elm --> createChildren -->
   1. 如果children不是
   2. checkDuplicateKeys --> 检查重复的Key
   3. 循环children 调用createElm
      1. 创建hello V 文本节点插入 ①中
      2. 创建hr标签插入①中
      3. 创建 _s 生产的文本插入 ①中
      4. 创建hr标签插入①中
      5. 创建button 标签和该标签下的text节点 并调用invokeCreateHooks（枚举cbs[create]下的方法进行对attres、class、event等属性进行更新和绑定【就是绑定当前DOM的属性和方法】） --> 接着将该元素插入①中
      6.  后续的button同上
   4. invokeCreateHooks --> 绑定DOM 元素的属性和方法（和上面invokeCreateHooks 的理解一样）
   5. 向body 插入已经递归生成好完整DOM的①
   6. createElm完成
3. parentElm存在 移除旧的DOM
4. invokeInsertHook 调用组件insert的钩子（无组件跳过）
5. 返回最后生成的 DOM （就是上面的①）

--> 跳回 update 还原 activeInstance 、prevEl（旧的div#app）的vue置为null、新的div#app的vue = vm（当前实例）

--> 跳回wacher.get 方法 --> popTarget（） 移除当前的watcher --> 返回value（undefined）

--> _mountComponent --> 调用mounted 钩子

### mount --> patch 完成首次DOM渲染

## 点击长大一岁

1. 触发第一个get  --> 获取this.info（实际访问this._data.info） --> 无Dep.target 接着到下一次get  --> 访问this.info.age -- > 无Dep.target
2. 接着触发set --> 设置的值不是一个obj|| arr --> observe 不进行绑定新的观察者绑定--> dep.notify()

### 调用当前数据对象对应的dep的dep.notify

1. 复制一份subs（观察当前数据变化的观察者此处是一个渲染watcher）
2. 循环调用watcher的update方法 --> **(1、懒加载将dirty属性置为true。2、sync为true 立刻调用 this.run() 执行get()方法进行获取|| 渲染 3、queueWatcher（this）把当前watcher放入一个队列中 在下一个tick中执行该watcher)**【不同逻辑不同方式】
3. queueWatcher --> 把传入的watcher  push或者splice插入 进queue（队列）中  -->  把等待状态置为true --> 立刻调用flushSchedulerQueue 或者在下一个tick中调用 
4. nexTick调用 --> 组装cb或者promise --> 如果不是pending状态 --> 改变状态 --> 根据 不同情况调用宏任务（macroTimerFunc）还是微任务（microTimerFunc）
5. 异步执行调用了macroTimerFunc() （其实是根据兼容性和性能选择更好的异步函数） --> 调用flushCallbacks（）-->
6. （callbacks这里说的回掉就是nextTick  push的方法）复制一份回调函数然后清除数组 --> 循环调用复制的回调中的内容 --> 此处只有一个函数就是调用flushSchedulerQueue -->

### flushSchedulerQueue

1. 改变flushing状态 = true 、 对queue（队列）进行从小到达排序 --> 3点都在源码的注释里面（主要就是让父组件在前子组件在后）
2. 遍历watcher队列 对watcher进行调用 --> watcher.before() （因为这个是渲染watcher所以会调用new时候传入的beforeUpdate钩子） --> watcher.run()  -->
3. 如果当前watcher没有被销毁（正在活跃的状态） -->  this.get() --> **现在就和当初渲染的逻辑基本一样** --> 直接调到调用

### updateComponent --> _update(\_render(),false)

1. **此过程会重新触发涉及渲染的变量的get而现在又是渲染阶段Dep.target存在 --> 重新对dep进行收集（依赖收集）**
2. 和第一渲染一样生成VNode （新的 VNode）
3. _update -->

#### _update --> 此时不是首次渲染所以vm.PrveVnode存在 走eles逻辑 vm.__patch\_\_(prevVnode,vnode)

1. 此时因为prveVnode不是原生的DOM 并且满足sameVnode --> 走 patchVnode逻辑
   - **patchVnode** -->
   - 判断新旧vnode的指针是否一样 --> 是否为异步的占位符节点 -->
   - 是否为静态节点 -->
   - 查看是否存在组件的prepatch钩子 --> 有就调用 --> 
   - 如果data有定义而且从自身往父找能找到能够用于渲染的tag --> 循环调用平台相关的update函数、并且如果data.hook中的upadate钩子存在(调用)
   - 区分一 else 逻辑 子父是不一样的文本节点更新文本节点。
   -  区分而 if逻辑 有以下4个可能
     1. 新child、旧childVNode都存在 而且指针不一样调用updateChildren **（一个VUE用于更新DOM的diff算法比较复杂根据实际情况跟着debugger走就懂了）**流程在后
     2. 新child定义 移除父child的文本节点以及调用addVnodes添加子vNode --> 循环新VNode调用createElm（就是递归创建真实的DOM）
     3. 旧childVNode定义 removeVnodes移除旧的vnode和DOM
     4. 旧childVNode是一个textVNode 移除
   - 如果是组件最后调用postpatch钩子
2. 回到patch --> 最后调用 invokeInsertHook（调用组件的insert钩子） --> 返回创建好的新的elm
3. 回到 _update 还原 
   1. prevActiveInstance
   2. 重设 prevEl.__vue__ = null; 、vm.$el.__vue__ = vm; 
   3. **这些都和以前一样**
4. 跳回Watcher.get -->  当前watcher出栈 --> 清楚这些依赖收集和储存到旧的 --> 返回value
5. 跳回run --> 跳出flushSchedulerQueue -->
6. 无其他queue 循环完成
7. 储存queue、activatedChildren --> 重置数据
8. 调用钩子
9. 结束了

#### updateChildren 流程

1. 定义一些变量（开始、结束 、新、旧的下标和Vnode）
2. checkDuplicateKeys 进行key检查
3. 进入while循环
   1. 第一个循环 第3个if (sameVnode(oldStartVnode, newStartVnode)) （msg变量）
      - patchVnode --> 因为Hello V 是一个文本节点而且一样所以直接走完了没有变化
      - 新旧StartVnode向右移动
   2. 第二个循环 第3个if （hr标签）
      - patchVnode --> 因为不是异步节点、不是静态节点、无text、无child 改了一下VNode 安然无恙的又走完了
      - 新旧StartVnode向右移动
   3. 第三个循环 第3个if（info变量）
      - patchVnode --> 因为info变量改变了 所以走到了 nodeOps.setTextContent(elm, vnode.text); 修改了一下文本节点
      - 新旧StartVnode向右移动
   4. 其他循环渲染Text和hr的 同理没有变化安然走完
   5. 来到渲染button 的循环 同样是第3个if
      - patchVnode  --> 因为button是有child的而且新旧都有 --> 直接跳到updateChildren吧 --> 但因为无变化所以不更新（因为和现在正在进行的循环一样逻辑所以跳了）
   6. 其他button同理
4. 循环完成
5. 满足 oldStartIdx > oldEndIdx 而且refElm 不存在 --> addVnodes 没添加任何东西





$attrs\$listrent\ Observer调用 \ this.walk -- 3、msg ，4、 info，5，hobby 9 name  10 age

1. 
2. init Data Observer 调用的
3. msg
4. info
5. new Observer -->  info
6. hobby 
7. new Observer --> info.hobby   array
8. name
9. age



get   hello v   push 3

访问info obj    push 4 --> 因为这个是一个对象在上面observe有返回值 --> 添加返回值的new Observe （__ob\_\_ ）  5

-->  访问数组 添加 6 而且observe 也是有返回值的添加7 

--> 添加name 8 和 age 9



在initData的时候已经实例化好Dep

在new Watcher 的时候调用this.get() --> 把当前的Watcher push 进 Dep.target 常量 --> 调用getter --> 实际调用updateCompoent --> 在调用render的时候 会处罚get 进行当前渲染Watcher的依赖收集



调用