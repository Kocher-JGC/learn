在理解响应式之前你需要对以下理解

1. new Vue --> mergeOpts 、init--> $mount --> mountComponent --> new Watcher --> render() --> update0 --> patch --> createElm渲染真实的DOM
   1. 合并配置都干了些为什么把你传入的配置合并成什么样子了
   2. init干了些什么生成了什么属性、（注意initData中如何对【data、props、methods、computed、watch】的处理） --> observe() 干了些什么
   3. _render 中如何生成VNode
   4. patch如何将VNode 里面 数据+属性+tag 渲染成真实的DOM



对整个渲染的流程熟悉了后，就需要理解

1. watcher 类、Dep 类、Observer类、以及很重要的defineReactive方法
2. 理解他们直接如何进行以来收集和 以及如何触发更新渲染DOM。
   1. 通过理解语法糖的定义理解运行流程
   2. 通过理解queueWatcher、flushSchedulerQueue、以及上面提到的类和方法 理解整个依赖的收集和更新的过程 --> 最终触发更新
3. 大体流程理解完后，分小块深入理解【data、props、methods、computed、watch】
4. 总而言之。学习重点在observer文件夹中的所有js

> 因为之前整个流程重点分析过所以例子中部分流程会简化
#简单开始 [simpleData（data、methods）](../HTML/simpleData.html)

## mergeOpts和initData

### mergeOpts

1. mergeMethods -->   无父直接返回传入的method
2. dataMethods --> 返回 mergedInstanceDataFn函数                                                                    

### initData

1. initMethods--> 调用bind函数修改函数调用的指针

2. initData --> getData() [调用merge时候返回的函数]--> 拿到返回值赋值到 vm.$options.data 

   -  循环data的key --> 检查可用性 如果是普通类型 调用 proxy进行代理访问

   - 调用observe 对data  进行 new Observer() --> 把所有的对象转换为响应式对象 -->

     - > 1、如果是数组则使用**原型方式修改或使用复制方式**修改（修改原数组的方法来实现 响应式） --> 再调用this.observeArray() -->  循环对每个元素进行observe定义
       >
       > 2、直接调用this.walk(value)  --> 枚举每个key 来进行defineReactive（）
       >
       > ** 注意**数组和defineReactive 来进行对observe的调用**（递归的设置响应语法糖） （小心被绕晕了）

     - 赋值this.value = 传入的data

     - this.Dep =  new Dep() (依赖收集的类)

     - def() --> 向data中加入__ob\_\_属性并且可枚举性为false

     - 调用 this.walk(obj) --> 循环obj的key 调用defineReactive（定义对应key的响应的语法糖） --> 经过检查后 --> **如果发现obj[key]是一个对象（满足typeof === 'object' 即可）递归调用observe**进行 new Observer或者返回已经实例的ob

     - 最后返回一个最大的 Observer

## $mount --> mountComponent

1. callHook(vm, 'beforeMount');  --> 组装 updateComponent函数
2. new Watcher（） --> watcher.get()
   - push当前Watcher --> targetStack
   - this.getter.call(vm,vm) --> updateComponent() -->

### updateComponent() -->

```javascript
(function anonymous() {
  with(this){
    return _c('div',{attrs:{"id":"app"}},[
      _v("\n    "+_s(msg)+"\n    "),
      _c('hr'),_v("\n    "+_s(info)+"\n    "),
      _c('hr'),_v(" "),
      _c('button',{on:{"click":function($event){growUp(1)}}},[_v("点我长大一岁")]),
      _v(" "),
      _c('button',{on:{"click":function($event){addArrayVal()}}}[_v("addArrayVal")]),
      _v(" "),
      _c('button',{on:{"click":function($event){addObjVal()}}},[_v("addObjVal")])])
  }
})
```

#### render 

1. _v --> 创建text的VNode 跳过
2. _s --> 实际上是shared/util.js 的toString方法 --> return 格式化好的字符串
3. _c('hr') , _c('button') -->  _createElement --> 返回渲染浏览器内置元素的VNode

#### update --> patch 

> update 存储（ prevEl 、prevVnode 、 preActiveInstance ）

patch -->

1.  oldVnode = emptyNodeAt(oldVnode); --> 创建了一个空的DOM VNode 用于替换原来的DOM （此后以 ①为别名）
2. createElm --> 调用原生方法创建真实DOM  = vnode.elm --> createChildren -->
   1. 如果children不是
   2. checkDuplicateKeys --> 检查重复的Key
   3. 循环children 调用createElm
      1. 创建hello V 文本节点插入 ①中
      2. 创建hr标签插入①中
      3. 创建 _s 生产的文本插入 ①中
      4. 创建hr标签插入①中
      5. 创建button 标签和该标签下的text节点 并调用invokeCreateHooks（枚举cbs[create]下的方法进行对attres、class、event等属性进行更新和绑定【就是绑定当前DOM的属性和方法】） --> 接着将该元素插入①中
      6.  后续的button同上
   4. invokeCreateHooks --> 绑定DOM 元素的属性和方法（和上面invokeCreateHooks 的理解一样）
   5. 向body 插入已经递归生成好完整DOM的①
   6. createElm完成
3. parentElm存在 移除旧的DOM
4. invokeInsertHook 调用组件insert的钩子（无组件跳过）
5. 返回最后生成的 DOM （就是上面的①）

--> 跳回 update 还原 activeInstance 、prevEl（旧的div#app）的vue置为null、新的div#app的vue = vm（当前实例）

--> 跳回wacher.get 方法 --> popTarget（） 移除当前的watcher --> 返回value（undefined）

--> _mountComponent --> 调用mounted 钩子

### mount --> patch 完成首次DOM渲染

## 点击长大一岁

