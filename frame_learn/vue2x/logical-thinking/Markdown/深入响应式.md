在理解响应式之前你需要对以下理解

1. new Vue --> mergeOpts 、init--> $mount --> mountComponent --> new Watcher --> render() --> update0 --> patch --> createElm渲染真实的DOM
   1. 合并配置都干了些为什么把你传入的配置合并成什么样子了
   2. init干了些什么生成了什么属性、（注意initData中如何对【data、props、methods、computed、watch】的处理） --> observe() 干了些什么
   3. _render 中如何生成VNode
   4. patch如何将VNode 里面 数据+属性+tag 渲染成真实的DOM



对整个渲染的流程熟悉了后，就需要理解

1. watcher 类、Dep 类、Observer类、以及很重要的defineReactive方法
2. 理解他们直接如何进行以来收集和 以及如何触发更新渲染DOM。
   1. 通过理解语法糖的定义理解运行流程
   2. 通过理解queueWatcher、flushSchedulerQueue、以及上面提到的类和方法 理解整个依赖的收集和更新的过程 --> 最终触发更新
3. 大体流程理解完后，分小块深入理解【data、props、methods、computed、watch】
4. 总而言之。学习重点在observer文件夹中的所有js

> 因为之前整个流程重点分析过所以例子中部分流程会简化
#简单开始 [simpleData（data、methods）](../HTML/simpleData.html)

## mergeOpts和initData

### mergeOpts

1. mergeMethods -->   无父直接返回传入的method
2. dataMerge --> 返回 mergedInstanceDataFn函数                                                                    

### initData

1. initMethods--> 调用bind函数修改函数调用的指针

2. initData --> getData() [调用merge时候返回的函数]--> 拿到返回值赋值到 vm.$options.data 

   - 循环data的key --> 检查可用性 如果是普通类型 调用 proxy进行代理访问

   - 调用observe 对data  进行 new Observer() --> 把所有的对象转换为响应式对象 -->

     - > 1、如果是数组则使用**原型方式修改或使用复制方式**修改（修改原数组的方法来实现 响应式） --> 再调用this.observeArray() -->  循环对每个元素进行observe定义
       >
       > 2、直接调用this.walk(value)  --> 枚举每个key 来进行defineReactive（）
       >
       > ** 注意**数组和defineReactive 来进行对observe的调用**（递归的设置响应语法糖） （小心被绕晕了）

     - 赋值this.value = 传入的data

     - this.Dep =  new Dep() (依赖收集的类)

     - def() --> 向data中加入__ob\_\_属性并且可枚举性为false

     - 调用 this.walk(obj) --> 循环obj的key 调用defineReactive（定义对应key的响应的语法糖） --> 经过检查后 --> **如果发现obj[key]是一个对象（满足typeof === 'object' 即可）递归调用observe**进行 new Observer或者返回已经实例的ob

     - 最后返回一个最大的 Observer

#### Dep的实例（简述理解new Dep过程能够更友好的理解依赖收集）

1. 第一第二个Dep在initRender的时候实例化的跳过（观察vm下的 $attrs、\$listeners 属性）
2. initData最后调用 observe(data,true) --> 调用new Observer（value）并且ob.vmCount++;
   - 在new Observer过程中会实例化一个Dep【第2】；、定义value的__ob\_\_属性指向Observer实例而且是不可枚举的
   - 调用this.walk 遍历value的key进行defineReactive
3. 第一个msg为字符串实例了一个Dep【第3】
4. 第二个info为对象实例了一个Dep【第4】又来到了observer的调用 --> 又实例了一个Observer【第5】--> this.walk()
5. 继续遍历key --> hobby【第6】 --> 是一个数组 --> new Observer 【第7】--> 数组每个元素是字符串不进行Dep定义
6. name【第8】、age【第9】

## $mount --> mountComponent

1. callHook(vm, 'beforeMount');  --> 组装 updateComponent函数
2. new Watcher（） --> watcher.get()
   - push当前Watcher --> targetStack
   - this.getter.call(vm,vm) --> updateComponent() -->

> **首次的依赖收集**
>
> 在new Watcher 的时候调用this.get() --> 把当前的Watcher push 进 Dep.target 常量 --> 调用getter --> 实际调用updateCompoent --> 在调用render的时候 会触发data的get 进而触发当前渲染Watcher的依赖收集（收集Dep）

### updateComponent() -->

```javascript
(function anonymous() {
  with(this){
    return _c('div',{attrs:{"id":"app"}},[
      _v("\n    "+_s(msg)+"\n    "),
      _c('hr'),_v("\n    "+_s(info)+"\n    "),
      _c('hr'),_v(" "),
      _c('button',{on:{"click":function($event){growUp(1)}}},[_v("点我长大一岁")]),
      _v(" "),
      _c('button',{on:{"click":function($event){addArrayVal()}}}[_v("addArrayVal")]),
      _v(" "),
      _c('button',{on:{"click":function($event){addObjVal()}}},[_v("addObjVal")])])
  }
})
```

#### render 

1. _v --> 创建text的VNode 跳过
2. _s --> 实际上是shared/util.js 的toString方法 --> return 格式化好的字符串
3. _c('hr') , _c('button') -->  _createElement --> 返回渲染浏览器内置元素的VNode

#### update --> patch 

> update 存储（ prevEl 、prevVnode 、 preActiveInstance ）

patch -->

1.  oldVnode = emptyNodeAt(oldVnode); --> 创建了一个空的DOM VNode 用于替换原来的DOM （此后以 ①为别名）
2. createElm --> 调用原生方法创建真实DOM  = vnode.elm --> createChildren -->
   1. 如果children不是
   2. checkDuplicateKeys --> 检查重复的Key
   3. 循环children 调用createElm
      1. 创建hello V 文本节点插入 ①中
      2. 创建hr标签插入①中
      3. 创建 _s 生产的文本插入 ①中
      4. 创建hr标签插入①中
      5. 创建button 标签和该标签下的text节点 并调用invokeCreateHooks（枚举cbs[create]下的方法进行对attres、class、event等属性进行更新和绑定【就是绑定当前DOM的属性和方法】） --> 接着将该元素插入①中
      6.  后续的button同上
   4. invokeCreateHooks --> 绑定DOM 元素的属性和方法（和上面invokeCreateHooks 的理解一样）
   5. 向body 插入已经递归生成好完整DOM的①
   6. createElm完成
3. parentElm存在 移除旧的DOM
4. invokeInsertHook 调用组件insert的钩子（无组件跳过）
5. 返回最后生成的 DOM （就是上面的①）

--> 跳回 update 还原 activeInstance 、prevEl（旧的div#app）的vue置为null、新的div#app的vue = vm（当前实例）

--> 跳回wacher.get 方法 --> popTarget（） 移除当前的watcher --> 返回value（undefined）

--> _mountComponent --> 调用mounted 钩子

### mount --> patch 完成首次DOM渲染

## 点击长大一岁

1. 触发第一个get  --> 获取this.info（实际访问this._data.info） --> 无Dep.target 接着到下一次get  --> 访问this.info.age -- > 无Dep.target
2. 接着触发set --> 设置的值不是一个obj|| arr --> observe 不进行绑定新的观察者绑定--> dep.notify()

### 调用当前数据对象对应的dep的dep.notify

1. 复制一份subs（观察当前数据变化的观察者此处是一个渲染watcher）
2. 循环调用watcher的update方法 --> **(1、懒加载将dirty属性置为true。2、sync为true 立刻调用 this.run() 执行get()方法进行获取|| 渲染 3、queueWatcher（this）把当前watcher放入一个队列中 在下一个tick中执行该watcher)**【不同逻辑不同方式】
3. queueWatcher --> 把传入的watcher  push或者splice插入 进queue（队列）中  -->  把等待状态置为true --> 立刻调用flushSchedulerQueue 或者在下一个tick中调用 
4. nexTick调用 --> 组装cb或者promise --> 如果不是pending状态 --> 改变状态 --> 根据 不同情况调用宏任务（macroTimerFunc）还是微任务（microTimerFunc）
5. 异步执行调用了macroTimerFunc() （其实是根据兼容性和性能选择更好的异步函数） --> 调用flushCallbacks（）-->
6. （callbacks这里说的回掉就是nextTick  push的方法）复制一份回调函数然后清除数组 --> 循环调用复制的回调中的内容 --> 此处只有一个函数就是调用flushSchedulerQueue -->

### flushSchedulerQueue

1. 改变flushing状态 = true 、 对queue（队列）进行从小到达排序 --> 3点都在源码的注释里面（主要就是让父组件在前子组件在后）
2. 遍历watcher队列 对watcher进行调用 --> watcher.before() （因为这个是渲染watcher所以会调用new时候传入的beforeUpdate钩子） --> watcher.run()  -->
3. 如果当前watcher没有被销毁（正在活跃的状态） -->  this.get() --> **现在就和当初渲染的逻辑基本一样** --> 直接调到调用

### updateComponent --> _update(\_render(),false)

1. **此过程会重新触发涉及渲染的变量的get而现在又是渲染阶段Dep.target存在 --> 重新对dep进行收集（依赖收集）**
2. 和第一渲染一样生成VNode （新的 VNode）
3. _update -->

#### _update --> 此时不是首次渲染所以vm.PrveVnode存在 走eles逻辑 vm.__patch\_\_(prevVnode,vnode)

1. 此时因为prveVnode不是原生的DOM 并且满足sameVnode --> 走 patchVnode逻辑
   - **patchVnode** -->
   - 判断新旧vnode的指针是否一样 --> 是否为异步的占位符节点 -->
   - 是否为静态节点 -->
   - 查看是否存在组件的prepatch钩子 --> 有就调用 --> 
   - 如果data有定义而且从自身往父找能找到能够用于渲染的tag --> 循环调用平台相关的update函数、并且如果data.hook中的upadate钩子存在(调用)
   - 区分一 else 逻辑 子父是不一样的文本节点更新文本节点。
   -  区分而 if逻辑 有以下4个可能
     1. 新child、旧childVNode都存在 而且指针不一样调用updateChildren **（一个VUE用于更新DOM的diff算法比较复杂根据实际情况跟着debugger走就懂了）**流程在后
     2. 新child定义 移除父child的文本节点以及调用addVnodes添加子vNode --> 循环新VNode调用createElm（就是递归创建真实的DOM）
     3. 旧childVNode定义 removeVnodes移除旧的vnode和DOM
     4. 旧childVNode是一个textVNode 移除
   - 如果是组件最后调用postpatch钩子
2. 回到patch --> 最后调用 invokeInsertHook（调用组件的insert钩子） --> 返回创建好的新的elm
3. 回到 _update 还原 
   1. prevActiveInstance
   2. 重设 prevEl.__vue__ = null; 、vm.$el.__vue__ = vm; 
   3. **这些都和以前一样**
4. 跳回Watcher.get -->  当前watcher出栈 --> 清楚这些依赖收集和储存到旧的 --> 返回value
5. 跳回run --> 跳出flushSchedulerQueue -->
6. 无其他queue 循环完成
7. 储存queue、activatedChildren --> 重置数据
8. 调用钩子
9. 结束了

#### updateChildren 流程

1. 定义一些变量（开始、结束 、新、旧的下标和Vnode）
2. checkDuplicateKeys 进行key检查
3. 进入while循环
   1. 第一个循环 第3个if (sameVnode(oldStartVnode, newStartVnode)) （msg变量）
      - patchVnode --> 因为Hello V 是一个文本节点而且一样所以直接走完了没有变化
      - 新旧StartVnode向右移动
   2. 第二个循环 第3个if （hr标签）
      - patchVnode --> 因为不是异步节点、不是静态节点、无text、无child 改了一下VNode 安然无恙的又走完了
      - 新旧StartVnode向右移动
   3. 第三个循环 第3个if（info变量）
      - patchVnode --> 因为info变量改变了 所以走到了 nodeOps.setTextContent(elm, vnode.text); 修改了一下文本节点
      - 新旧StartVnode向右移动
   4. 其他循环渲染Text和hr的 同理没有变化安然走完
   5. 来到渲染button 的循环 同样是第3个if
      - patchVnode  --> 因为button是有child的而且新旧都有 --> 直接跳到updateChildren吧 --> 但因为无变化所以不更新（因为和现在正在进行的循环一样逻辑所以跳了）
   6. 其他button同理
4. 循环完成
5. 满足 oldStartIdx > oldEndIdx 而且refElm 不存在 --> addVnodes 没添加任何东西

## 基本注意事项（$set和直接为对象||数组添加成员的区别）

错误：

```javascript
this.info.newVal = 'addNewValFailed';
this.info.hobby[3] = 'failedAdd'; // 失败
console.log(this.info);
```

在控制台可以看到数据是改变的，但是并没有触发defineReactive定义的set语法糖仅仅触发了get的语法糖（因为Object.defineProperty（）不能监测数组的变化和新增对象属性的变化）

使用$set方法

**数组实际上是调用set的这段代码：**

```javascript
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    // 修改长度删除key对应项替换为val
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
```

1. 在此前的分析中提到过监测数组的改变其实是通过监测数组原生的某些方法来进行间接监测的。
2. 而监测的内部 调用的是 ob.observeArray()  --> ob.dep.notify() 进行手段重新订阅观察者和主动触发更新。（ob是一开始new Observer时候储存的）

**对象：**

1. 检查是否已存在原本的对象上--> 存在的表示已经订阅过的直接返回值就行。
2. 否则：如果不是响应式对象直接复制val返回val（没有进行new Observer所以ob不存在）
3. 主动调用defineReactive进行订阅新的key的变化 --> 然后主动调用ob.dep.notify() 进行更新和 返回val

**另一种错误：**

```javascript
this.info.addErrVal = 'addErrVal';
this.info.age++;
setTimeout(()=>{ // 不合理但是为了演示理解错误
  this.info.addErrVal = 'error';
},2000)
```

1. 对于此种情况视图在第一次的时候能够更新数据，因为age是被观察的属性，当在nextTick重新渲染页面的时候拿到的是变化后的info的值，所以视图的数据会更新。
2. 而在2秒后数据更新了视图并没有更新。因为上一步即便视图更新了，但是并没有对addErrVal属性进行观察所以不会触发set的语法糖，以至于不会触发视图的更新。
3. 但是赋值前都会触发get进行一次依赖的收集。（在思考这样每次都收集是不是不太好。？）

# computed AND watch（[watch.html](../HTML/watch.html)）

## mergeOpts 和initState

### mergeOpts

1. dataMerge -> 返回 mergedInstanceDataFn函数    
2. computedMerge --> 返回 childVal（传入本身）
3. watchMerge -->  返回 childVal（传入本身）

### initState

1. initData --> getData()、proxy代理访问、observe递归把属性都订阅了（和之前差不多简述）

2. initComputed --> 

   - const watchers = vm._computedWatchers = Object.create(null)

   - getter = 枚举computed --> **函数直接拿函数（computed[key]），否则拿其对应的get（computed[key].get）**

   - new Watcher（vm，getter，noop(cb)，{ computed: true }）**（非服务端渲染调用）**

     -  实例化watcher 赋值属性、赋值getter函数等
     -  computed 为true不调用get，仅仅new Dep（但新版本并没有new Dep）

   - !(key in vm) --> **defineComputed(vm, key, userDef)**

     - 组装obj -->

     - 
       ```javascript
       var obj = {
        enumerable: true,
        configurable: true,
        get: computed[key].get,
        set: computed[key].set
       }
       Object.defineProperty(vm, key, obj)
       ```

     - 定义访问属性（计算属性的访问）的get和set

3. initWatch -->  createWatcher --> 最终还是调用vm.$watch( key , handler , options)

   > 注意其watcher的实例和依赖的收集是如何进行的。watcher.get 发生了什么。。

   1. initWatcher --> 枚举watch --> 
      - 如果watch[key] 是一个数组 --> 循环调用createWatcher进行new Watch
      - 否则  直接调用createWatcher
   2. createWatcher --> （标准化参数）
      - 如果handler 是 [object Object] --> options = handler 、 handler = options.handler
      - 如果handler 是string --> handler = vm[handler]
   3. vm.$watch --> 
      - 先检查一次如果handler为 [object Object]  则 调用createWatcher 
      - 储存options而且 options.user = true;
      - const watcher = new Watcher(vm, expOrFn, cb, options) 真正的调用watcher去实例化
         - 又来到了我们熟悉的watcher的实例化，以及调用get来进行该watcher对应的依赖收集
         - 值得注意的是 传入options.deep = true 的一次new Watcher
         - 在this.getter.call(vm,vm)的时候 (当前实例的Watcher收集了2个依赖【defineReactive、new Observer】)
         - 而this.deep 为true  调用traverse（value）【{age:1}】--> 调用_traverse()
         - 分array和object 进行递归的调用_traverse()**（在调用的过程中会触发属性的get从而触发依赖的收集）**
         - **注意点二：在info.age watcher的实现的时候注意 parsePath 访问属性和触发get进行依赖收集。**
      - 实例化完成后 发现 options.immediate 为true **立刻执行一下刚刚才定义的watcher** 
      - 并返回销毁watcher的函数

## $mount --> _render --> _update (大部分一样的跳过)

1. 当_render 调用前 获取 计算属性name的时候 调用get 实际调用--> initComputed 时候定义的函数(computedGetter)
   1. 先拿到watcher 并且watcher存在
   2. 如果该computed被污染的（watcher.dirty） 调用 watcher.evaluate() 进行计算求值 【新增的逻辑】
   3. 如果Dep.target存在则进行依赖收集
   4. 最后返回求出的值或者没变的值 （这也是个性能的优化）
   5. **而旧版本直接是判断watcher 存在就进行依赖收集和 返回watcher.evaluate()的求值**
2. 后面的render也是和先前的没多大差别，值得注意的是get属性值的时候的依赖收集的watcher的个数和先后循序（vm._init的流程决定的基本的先后顺序。）_

**既然数据已经出来后面的_update和createElm 没多大差别可以跳过**

## 两秒后触发的数据更新触发（set）

> 触发set之前都会触发get
>
> 注意：同时为了watcher的重复添加 有一个 has 的变量来记录已经添加的watcher的id，保证每个watcher只被添加一次到队列里面

1. 触发info.age 的set --> 改变先前存的val --> dep.notify() 

   - 复制一份subs（就是订阅了该数据变化的watcher） -->  按照watcher实例的先后排序（id排序） 【在新版本中加了async的判断再去排序】

   - 循环subs调用其对应的update方法（3个update的调用）

     1. 直奔 queueWatcher（this）调用 -->  向queu.push(wathcer)【传入的watcher】--> waiting = true 调用nextTIck（flushSchedulerQueue） -->在下一个tick中调用flushSchedulerQueue真正更新

        > nextTIck组装一个异步的回调或者promise。调用宏任务或者是微任务。理解原理即可（就是异步函数调用的实现）

     2. 因为waiting  = true 、flushing = false 所以后面的 queueWatcher 只进行对queue（队列）进行push操作

2. 后面的 vm.firstName 同理 ueueWatcher 只进行对queue（队列）进行push操作

3. 但是vm.lastName 就不一样 因为 watcher.sync = true 所以会走 this,.run() 逻辑

   1. 主动调用this.get（）获取旧的值
   2. 判断新旧值不等或者是一个Obj或者deep为true
      - 设置新值
      - 调用watcher的cb（就是实例化的时候传入的第3个参数）【区别在于user会try一下】
   3. 而其他的watcher同理 只进行对queue（队列）进行push操作

### 来到了nextTick（异步触发flushCallbacks)

> 1. 改变pending 状态 = false 
> 2. 循环 callbacks 并调用 （本次只有一个）--> flushSchedulerQueue） 

#### flushSchedulerQueue

> 在循环的时候每次都对queue.length 求值（因为在调用watcher的时候有可能对导致长度的变化）
>
> <font color="#b61717">比如说一个bug </font>
>
> 'age'(newValue, oldValue) { this.age = Math.random() }
>
> 这样会一直对这个userWatcher进行收集，最终会触发 circular[id] > MAX_UPDATE_COUNT 逻辑。主动终止这个无限循环

1. flushing 状态改为 true;
2. 对queue进行id大到小排序（原理还是看代码解析，简单就是先父后子）
3. 循环调用queue --> 调用watcher.before 和 watcher.run() 
4. 调用run --> 该组件没有被销毁active = true 
5. 调用this.getAndInvoke把this.cb传入（cb就是我们自定义的watcher）
   - getAndInvoke --> 调用this.get() 求一次值。
   - 新旧值不等 改变新值。调用this.cb --> 实际是传入的函数也就是userWatcher

**注意：走流程打debugger的时候注意观察info的变化，因为info是一个obj所以其属性一但改变，与其引用关系的值都变化了。所以输出的新旧的值都是一样的。**

_最后一个watcher是渲染watcher。然而此前已经分析非组件的更新和调用updateChildren的diff算法的流程，此次与之，没有太大的差别。直接跳过。下面是一个组件的例子会详细解说DOM的更新。_

# 组件的更新和props [componentUpdate](../HTML/componentUpdate.html)





