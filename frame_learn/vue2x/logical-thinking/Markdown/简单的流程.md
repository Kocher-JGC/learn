# 简单的Vue的创建

```html
<div id="app">
    <span class="color-red">
      {{ msg }}
    </span>
  </div>

  <script>
    window.onload = function() {
      new Vue({
        el: '#app',
        mounted() {
          console.log(this.message); // 代理访问的证明
          console.log(this._data.message);
        },
        data() {
          return {
            msg: 'hello V'
          }
        },
      });
    }
  </script>
```

## 1、_init

1. 记录唯一uid、记录vue实例为true
2. mergeOptions
3. set  renderProxy
4. initLifecycle(vm) // 初始化生命周期钩子
5.  initEvents(vm) // 初始化事件中心 // 初始化事件中心实际复制父组件事件
6. initRender(vm) // 初始化渲染
7. callHook(vm, 'beforeCreate')    
8. initInjections(vm) // resolve injections before data/props解决注入问题
9. initState(vm)//初始化数据中心 data、props、computed、watcher 等等。
10.  initProvide(vm) // resolve provide after data/props// 解决后提供的数据/道具？？ // 难道是针对函数形式的么？
11. callHook(vm, 'created')
12. if（el） vm.$mount(el)

## 2、mergeOptions

1. resolveConstructorOptions  // Cotr: 在第一次new Vue的时候传入的是Vue Class // 显然没有父级-->直接返回Vue
2. parent --> 就是第一的结果
3. child --> new 时候传入的 opts
4. vm  --> new Vue
5. 标准化（props、inject、directives）//显然这里不需要执行
6. 不是Vue或者组件（!child._base）
   - 没有extends（扩展）、和mixins（混入） 直接跳过
7. 枚举parent --> 调用mergeField 对应执行正确的start函数
   - components、directives、filters 执行 (mergeAssets) --> object.create 将父级属性、方法的复制到opts上对应key的原型链上，如原来父级的keep-Alive组件就会挂载到opts的components.__propto\_\_ 上
   - _base 无 执行 （defaultStrat）--> 子无\_base直接拿父的
8. 再枚举子（传入的opts）// 执行7的merge操作**（虽然内部是使用浅拷贝可以保留父级，但是存在相同key这样无形中又会对父再进行Object.create,这是一个性能的开销）**

## 3、set RenderProxy

1. 通过理解merge得知opts无render，new Proxy（vm, hasHandler）

## 4、