# 编译人口





**事例代码::**

```javascript
new Vue({
  el: '#app',
  template: `
  <div>
    <ul :class="bindCls" class='list-wrap' v-if=isShow>
      <li v-for="(item,index) in data" @click="clickItem(index)">{{ item }}:< {{ index }} </li>
    </ul>
    <p v-else>no msg...</p>
    <div><p> static and staticRoot </p></div>
    <p> static and no staticRoot </p>
  </div>`,
  data() {
    return {
      bindCls: 'activeClass',
      isShow: true,
      data: [ 'A', 'B', 'C']
    }
  },
});
```



**入口 -->  _ini --> $mount -->  compilerToFunctions() --> compiler() --> baseCompiler()  --> parse()**

**其中各部分调用进行选项的处理、兼容的处理、以及事前的准备跳过。源码中有对应的注释。**

# parse(生成AST节点)

> 1. commet节点的解析就是简单的正则和判断是否保留
> 2. 浏览器兼容写法的匹配和doctype的匹配都是简单的advance(移动html下标)

1. 从options中拿到 warn 处理的函数、web平台相关的有（判断pre标签、某些标签必须使用prop进行属性绑定、nameSpace获取的函数）web平台相关的模块处理有（transforms有class和style处理的函数、preTransforms有对input标签处理的函数）
2. 获取分隔符、定义变量函数等
3. 重点 --> 调用parseHTML

### parseHTML调用

1. 定义变量(stack、expectHTML、isUnaryTag、canBeLeftOpenTag检查函数、index、last、lastTag)
2. while循环开始解析HTML

#### 第一次循环(div的解析)

1. lastTag = undefined 而且 textEnd === 0 开始检查div
2. 来到Start  Tag的检查 --> parseStartTag() --> 满足html.match(startTagOpen) --> 获取到了div标签
3. 并往下走,移动html的下标并组装match匹配的对象,对attr进行解析和移动html的下标同时每次解析判断是不是end(匹配>或者/>)   --> 返回match结果
4. 匹配到的是标签而且有结果 --> 调用handleStartTag() 【第一次写完整点】
   1. 检查HTML的规范
   2. 对attrs进行标准化处理
   3. 不是一元标签向stack中推入当前元素和内容并且记录lastTag = tagName
   4. 调用options.start对标签进行进一步解析 --> (最大的作用添加了root)
5. 因为第一次解析的是div一个普通标签基本上的运行都是跳过的,.(注意理解流程就行)
6. 返回while循环 ,对HTML进行移动一位,跳出本次循环

### 空格的解析(因为ul标签和div标签之间有空格所以textEnd的值不为0,来到如下代码)

```js
var text = (void 0), rest = (void 0), next = (void 0);
if (textEnd >= 0) {
  rest = html.slice(textEnd);
  while (
    !endTag.test(rest) &&
    !startTagOpen.test(rest) &&
    !comment.test(rest) &&
    !conditionalComment.test(rest)
  ) {
    // < in plain text, be forgiving and treat it as text
    next = rest.indexOf('<', 1);
    if (next < 0) { break }
    textEnd += next;
    rest = html.slice(textEnd);
  }
  text = html.substring(0, textEnd);
  advance(textEnd);
}

if (textEnd < 0) {
  text = html;
  html = '';
}

if (options.chars && text) {
  options.chars(text);
}
```

1. textEnd == 11 大于 0 而且不满足while里面的条件
2. 截取字符串,移动HTML的位置
3. 调用options.chars解析 --> 都是空格 trim 就没了 --> 跳出函数
4. 下一次循环

### 第二次循环(ul的解析)

1. 直接来到Start tag 的解析 调用parseStartTag() -->
2. 切到了ul标签并且在attr解析的时候解析到了3个值[:class,class,v-if]  (在解析优化的时候可以注意到一个FF的bug如何组装的)
3. 移动HTML下标和返回结果
4. 调用handleStartTag() --> 
   1. 正规写法跳过HTML检查来到 循环
   2. 循环对attr属性进行标准化将数组转化为{name,value}的形式
   3. 入栈,修改lastTag , 调用options.start --> 对内容进行进一步解析
5. options.start调用
   1. 创建createASTElement 创建AST节点 , 跳过ns和禁止标签的检查
   2. preTransforms 对节点进行解析  <span style="color: #dc3545">(显然不是input跳过不解析)</span>
   3. 不是pre标签而且是未解析标签 --> v-if属性存在 processIf() 
      - 在el.attrsList中获取v-if属性并删除
      - el.if = exp(isShow)
      - 调用addIfCondition向el.ifCondition添加第一个if条件
      - 退出函数
   4. processElement() -->
      1. processKey() 无key  --> element.key = undefined , element.plain = false
      2. 不是ref,slot,component跳过 (实际该解析很简单阅读源码或者看源码注释即可)
      3. 循环调用transforms 对class,style进行解析
         - 得到el.staticClass = "ist-wrap" , el.classBinding = bindCls
      4. processAttrs --> 前面解析了3个这时候没有了所以直接退出
   5. 跳回start的调用
   6. 向下走对树进行管理 --> 父级(div)添加Children以及element添加parent
   7. 修改currentParent 和 stack (原始父级和栈)
6. 跳出start调用 --> 跳出handleStartTag调用
7. 移动HTML下标 --> 退出循环

### 第三次循环(同样跳过空格解析,解析li)

1. 来到start Tag --> parseStartTag()
2. 同样组装了数据返回,解析出 li标签和attr中2个值 --> handleStartTag -->
3. HTML标准检查, 元素入栈 , 修改lastTag ,调用start -->
4. options.start -->
   1. 前面的没什么不一样来到, processFor 解析v-for -->
   2. parseFor
      1. let inMatch = exp.match(forAliasRE); 分割出 in左右的字符串
      2. res.for = inMatch[2]
      3. 接着 (item,index) 去括号 分割和赋值
      4. res.alias = item , res.iterator1 = index (只有2个值所以iterator2没有)
      5. 返回结果
   3. 把结果全部映射到el(AST节点)中
   4. processAttrs --> 此时attrsList有一个元素进入循环
   5. name = @click ,调用addHandler添加事件(事件比较复杂有一个例子单独讲)
   6. 解析完后AST节点多了一个events = {click: {value: "clickItem(index)"}}
   7. 跳出prcoessAttrs --> 跳出processElements
   8. 和上述一样对树进行管理(修改currentParent,el.parent,Children,stack)
5. 回到start Tag 移动HTML下标 --> 退出循环

#### 第四次循环(解析文本节点[{{ item }}:< {{ index }} ])

1. textEnd =11 (不等于0且大于0)
2. 来到上面解析空格的那段代码
3. rest 等于HTML截取11为后的内容,进入while循环
4. 不满足 endTag,startTagOpen,comment,ConditionalComment
   - 截取''<''位置 ,改变textEnd和rest 继续循环
   - 此时 rest开头为\</li>满足闭合标签(endTag)
   - 退出循环
5. text = html截取25(textEnd)位,而HTML移动25(textEnd)位
6. 调用options.chars对text进行解析
   1. text不是顶级,不是ie的textarea标签,不是pre标签
   2. 对text 进行 parseText解析 --> (text解析看源码解析)
   3. 得到结果expression: "_s(item)+":< "+_s(index)+" "",tokens: xxx 
   4. 向其父级的Children中push type为2的AST节点(有插值表达式的节点)
7. 解析完成退出循环

### 第五次循环(解析\</li>标签) [第六此循环解析\</ul>标签类同]

1. 来到End Tag -->
2. 先移动HTML下标再调用 parseEndTag 对 结束标签进行解析
3. parseEndTag -->
   1. 在栈(stack)中寻找相同的标签(li) --> 找到退出循环,没有找到pos--接着找
   2. stack中有3个元素, pos-- 后 = 2 大于0
   3. 再来一次循环检查元素的闭合是否正常(stack的长度和pos的关系) , 并且每次循环都调用options.end
   4. options.end --> 
      1. 删除尾随的空格
      2. 当前标签(元素)出栈,修改currentParent
      3. 调用closeElement进行标签的闭合
      4. closeElement --> 修改v-pre,和pre标签对应 的属性,以及调用postTransforms(在web平台无内容)
   5. 循环结束 --> stack.length = pos (修改栈的正确内容和元素) , 然后修改lastTag
4. 退出parseEndTag --> 退出循环

### 第七次循环(解析\<p v-else>)

> 这是一个比较绕也比较重点的一个理解,所以单独说了一下

1. 基本上和之前的解析都没什么大区别值得注意的一点是
2. if (currentParent && !element.forbidden) -->
3.  if (element.elseif || element.else)  --> 为true
4. 调用了processIfConditions()
   1. findPrevElement --> 从后往上找找到第一个是DOM的兄弟(并在找的时候对Children进行优化)
   2. 判断 prev 并且 prev.if  --> 调用addIfCondition() 进行对prev 元素新增一个if的判断条件

### 后面的循环(因为后面的比较简单就不单独说明)

1. 后面解析的都是普通的标签,没有属性可以解析 ,可以理解为和一开始的div差不多
2. 在解析text的时候因为不是插值表达式和 所以生成的AST节点type为3
3. 在循环结束后 parseEndTag() 对变量进行清除

额外的:

1. 一元标签直接调用closeElement进行闭合
2. root是if 的情况
3. plain属性在processElement解析的时候 在el.key 和el.attrsList.length == 0 的时候 会改变成true

### 最后返回root （一个完整的描述DOM的AST树）

## 注意事项

### handleStartTag 中 -->

```js
// 形如 <p><div></div></p> 这是不符合规范的主动闭合
if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
  parseEndTag(lastTag)
}
```

```js
// 形如 <p><p></p></p> 也是不符合规范的主动闭合(产生这些情况的标签canBeLeftOpenTag)
  if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
    parseEndTag(tagName)
  }
```

### parseEndTag中 --> 

```js
else if (lowerCasedTagName === 'br') { // 一元标签br的特殊处理 </br>(不规范)
  if (options.start) {
    options.start(tagName, [], true, start, end)
  }
// 因为上面的一些不符合规范的写法等形如只剩下 </p> 就手动调用start 生成<p>标签 
} else if (lowerCasedTagName === 'p') {
  if (options.start) {
    options.start(tagName, [], false, start, end)
  }
  if (options.end) {
    options.end(tagName, start, end)
  }
}
```



# optimize(优化AST[标志静态节点和静态根])

> 优化的内容比较少,主要是标志属性,目的:(源码的解析)
>
> 1、将它们提升为常量，这样我们就不再需要在每次重新渲染时为它们创建新的节点；
>
> 2、在更新（修补）过程中完全跳过它们。
>
> 内容虽然少但是不要被递归绕晕了,判断也简单,就简单的说明一下.

1. 生成isStaticKey函数 --> 判断是否静态key
2. 生成检查平台保留标签的函数（html原生标签） -->isPlatformReservedTag
3. isStatic函数
   1. type == 2 --> 表达式文本 --> 一定不是静态的
   2. type == 3 --> 纯文本一定是静态的
   3. pre属性为true 的时候 --> 是静态节点
   4. 都满足的情况为true --> 是静态节点
      -  无动态绑定数据、[if、for、等]
      - 检查标记是否为内置标记。标签形如[slot,component]
      - 必定是HTML原生标签（不是组件） 
      - 是否为template的子级 
      - 并且node的所有key都是静态key (Object.keys(node).every(isStaticKey) )

### markStatic(root) 标记静态节点

1. div --> isStatic --> true
2. 循环Children --> 
   1. ul --> 有数据绑定 --> isStatic 为false --> 递归调用markStatic 标志child的Static
      - 而且li 也有数据绑定 --> isStatic 也为false
      - li下的表达式是插值表达式 --> isStatic 也为false
      - child的Static为false --> div[root] 的Static  --> true --> false
   2. 而后续的空字符串,div,p都是静态文本所以 isStatic 都为true.
3. 如果有  node.ifConditions 属性则循环并对其内容进行标记
   1. 循环拿到其渲染体block 然后调用MarkStatic对静态节点进行标记 --> 而p的else 属性不是静态属性key --> Object.keys(node).every(isStaticKey) --> 为false 所以 该元素的Static = false 
   2. 而block.Static为false 则会导致 node.Static(父级)也为false

### markStaticRoots(root,isInFor) 标记静态根

1. 仅对DOM(element) 进行标记

2. 如果是静态节点或者是一次的节点 会有一个staticInFor = isInFor

3. ```js
   if (node.static && node.children.length && !(
       node.children.length === 1 &&
       node.children[0].type === 3
     )) {
       node.staticRoot = true;
       return
     } else {
       node.staticRoot = false;
     }
   ```

   显而易见 

   1. 不为Static节点的 StaticRoot = false
   2. 而需要staticRoot = true 的情况下需要 node.static = true , node.children 有长度,而且不能是(只有一个Children,该Children是静态文本[vue源码解析说为了性能的优化]

4. 接着还是循环Children递归执行或者有if判断体递归执行进行标记

# generate(CodeGen)