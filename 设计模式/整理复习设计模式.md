读完菜鸟教程里面的设计模式的概念和理解，学到了一些以前没有学到的，复习了用过的以及加深了印象和理解，感觉很有用就总结一下分享一下。[链接](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)

------

<div align=center>
  <img src="..\assets\img\the-relationship-between-design-patterns.jpg" alt="关系图" />
</div>

# 设计模式的六大原则

**1、开闭原则（Open Close Principle）**

开闭原则的意思是：<font color=#dc3545>**对扩展开放，对修改关闭**</font>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是**为了使程序的扩展性好，易于维护和升级**。想要达到这样的效果，我们需要**使用接口和抽象类**，后面的具体设计中我们会提到这点。

**2、里氏代换原则（Liskov Substitution Principle）**

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，**任何基类可以出现的地方，子类一定可以出现**。LSP 是继承**复用**的基石，只有当派生类可以**替换**掉基类，且**软件单位的功能不受到影响**时，基类才能真正被复用，而派生类也能够在基类的基础上**增加新的行为**。里氏代换原则是对开闭原则的补充。实现开闭原则的**关键步骤**就是抽象化，而基类与子类的**继承关系**就是**抽象化的具体实现**，所以<font color=#dc3545>**里氏代换原则是对实现抽象化的具体步骤的规范**</font>。

**3、依赖倒转原则（Dependence Inversion Principle）**

这个原则是开闭原则的基础，具体内容：<font color=#dc3545 >**针对接口编程，依赖于抽象而不依赖于具体。**</font>

**4、接口隔离原则（Interface Segregation Principle）**

这个原则的意思是：**使用多个隔离的接口，比使用单个接口要好**。它还有另外一个意思是：**降低类之间的耦合度**。由此可见，其实设计模式就是<font color=#dc3545>**从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合**</font>。

**5、迪米特法则，又称最少知道原则（Demeter Principle）**

最少知道原则是指：**一个实体应当尽量少地与其他实体之间发生相互作用**，使得<font color=#dc3545>**系统功能模块相对独立**</font>。

**6、合成复用原则（Composite Reuse Principle）**

合成复用原则是指：<font color=#dc3545>**尽量使用合成/聚合的方式，而不是使用继承**</font>。



# 设计模式 Design Patterns（33种）

## 创建型模式

> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

### 工厂模式（Factory Pattern）

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过**使用一个共同的接口来指向新创建的对象**。

**做法：**定义一个创建对象的接口，子类去决定实例化哪一个工厂类。（实例的创建延迟到子类执行）；

**优点：**1、一个调用者想创建一个对象，只要**知其名称就可以了**。2、扩展性高，如果想增加一个产品，只有扩展一个工厂类就可以。3、屏蔽产品的具体实现，调用者只关心产品的接口。

**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

**应用实例：** 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

**注意：**

- 任何需要生成复杂对象的地方，都可以用。
- 复杂对象适合使用工厂模式，而简单的直接new就行（直接调用）
- 不要盲目使用工厂模式，添加系统复杂度。

**一、一句话概括工厂模式**

-  **简单工厂**：一个工厂类，一个产品抽象类。
-  **工厂方法**：多个工厂类，一个产品抽象类。
-  **抽象工厂**：多个工厂类，多个产品抽象类。

**二、生活中的工厂模式**

-  简单工厂类：一个麦当劳店，可以生产多种汉堡。
-  工厂方法类：一个麦当劳店，可以生产多种汉堡。一个肯德基店，也可以生产多种汉堡。
-  抽象工厂类：百胜餐饮集团下有肯德基和百事公司，肯德基生产汉堡，百事公司生成百事可乐。

### 抽象工厂模式（Abstract Factory Pattern）

​	抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。

​	在抽象工厂模式中，**接口是负责创建一个相关对象的工厂**（本身就是工厂），**不需要显式指定它们的类**。每个生成的工厂都能按照工厂模式提供对象。

 **做法：（在一个工厂里聚合多个同类产品。）** 创建和实例接口的实体类。创建一个抽象工厂类，让实体类成为抽象工厂AbstracFactory的扩展。通过抽象工厂定义/接口创建工厂的创造器/生成器。

**优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

**缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

**实例应用：**抽象工厂能够同时生产鼠标、键盘（父级工厂提供2个接口一个是生产鼠标，另一个是生产键盘），戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。

**注意：**

- **产品族难扩展，产品等级易扩展。**
- 如何抽象产品和具体实现，注意产品族的扩展和维护。划分等级的时候分清楚产品族的关系

### 单例模式（Singleton Pattern）

​	这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了**一种访问其唯一的对象的方式**，可以直接访问，不需要实例化该类的对象。（最简单的设计模式）

**做法：**定义一个类，保证全局只有一个实例，并提供一个全局的访问接口。

**优点：** 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。

**缺点：**没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

**应用：**1、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接。2、全局类的实例化然后多次调用。

**注意：**

- 单例类只能有一个实例。
- 单例类必须自己创建自己的唯一实例。
- 单例类必须给所有其他对象提供这一实例。



### 建造者模式（Builder Pattern）

建造者模式（Builder Pattern）使用**多个简单的对象一步一步构建成一个复杂的对象**。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

**做法：**将构建和表现分离 --> 通过不同参数或者不同配置，生成或混入不同方法（表现或结构），最后创建成一个新的实例（不同的表示方式）。

**优点：** 1、建造者独立，易扩展。 2、便于控制细节风险。

**缺点：** 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。

**应用：**1、一般使用在一些基本部件不会变，而其组合经常变化的时候。2、组件化开发  -->团队中模块化分工/管理。3、需要生成的对象内部属性本身相互依赖。4、需要生成的对象具有复杂的内部结构。

**注意：**

- **将一个复杂的构建过程与其表示相分离**

- 建造者模式更关注与零件装配的顺序（实例组装的过程/逻辑的过程）；

- 如何划分每一个零件（组件/方法等）；

- 设计过程中注意：建造者、监工、使用者（客户）之间的关系。


### 原型模式（Prototype Pattern）

​	原型模式（Prototype Pattern）是用于**创建重复的对象**，同时又能**保证性能**。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	这种模式是实现了一个原型接口，该接口用于创建**当前对象的克隆**。当直接创建对象的代价**比较大**时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

**做法：**用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。（关键在于：1、如何深度克隆。2、隔离类对象的使用者和具体类型（具体类型容易变化）之间的耦合关系。

**优点：** 1、性能提高。 2、逃避构造函数的约束。

**缺点：** 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。

**应用：**

1. **类的初始化**、重复创建的对象（类）。克隆类/对象。
2. **资源优化场景**
3. **一个对象多个修改者的场景**
4. 通过 new 产生一个对象需要**非常繁琐的数据准备或访问权限**，则可以使用原型模式。
5. 一个对象需要提供给其他对象访问，而且**各个调用者可能都需要修改其值时**，可以考虑使用原型模式拷贝多个对象供调用者使用。
6. 逃避构造函数的约束

**注意：**

- 原型链通过拷贝对象来生成一个新对象。（js中newObj继承prototype链上的方法亦如此）
- 一个系统应该独立于它的产品创建，构成和表示。
- 为了避免创建一个与产品类层次平行的工厂类层次时
- 当一个类的实例只能有几个不同状态组合中的一种时，注意其实例管理、耦合、变量等关系。



## 结构型模式

> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。

### 适配器模式（Adapter Pattern）

​	适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

**用来做兼容操作的模式。**

**做法：**（一般可以选择惰性函数）在类的初始化/类的调用，之前**检查兼容**，使其能够选择正确**兼容的方式工作**。

**优点：** 1、可以让任何**两个没有关联的类**一起运行。 2、提高了**类的复用**。 3、增加了类的透明度。 4、灵活性好。

**缺点：** 1、**过多地使用适配器，会让系统非常零乱，不易整体进行把握。**比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。

**应用：**1、接口/系统/版本/等兼容。2、业务逻辑的适配，如权限/路由/订单数据，等

### 桥接模式（Bridge Pattern）

​	桥接（Bridge）是用于把**抽象化与实现化解耦**，使得二者可以**独立变化**。这种类型的设计模式属于结构型模式，它通过提供**抽象化和实现化之间的桥接结构，来实现二者的解耦**。

​	这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。

​	**将抽象部分与实现部分分离，使它们都可以独立的变化。**

**用法：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。（抽象类依赖实现类）

**优点：** 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。

**缺点：**桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。

**应用：**1、解决多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。2、经纬度的独立变化。

### 过滤器模式（Filter Pattern）

​	过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过**逻辑运算以解耦的方式把它们连接起来**。这种类型的设计模式属于结构型模式，它**结合多个标准来获得单一标准**。

​	**用法：**创建一个类和接口的定义，以及实现该接口的实体类。然后根据定义的标准来对对象的过滤。

### 组合模式（Composite Pattern）

​	组合模式（Composite Pattern），又叫部分整体模式，是用于**把一组相似的对象当作一个单一的对象**。组合模式依据**树形结构**来组合对象，用来**表示部分以及整体层次**。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

​	这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

**用法：**将对象组合成树形结构以表示”部分-整体"的层次结构。处理单个对象和组合对象的使用的一致性。

**优点：** 1、高层模块调用简单。 2、节点自由增加。

**缺点：**在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。

**应用：**1、树枝和叶子实现统一接口（由树枝内部组合这些接口）。2、部分、整体的场景，如菜单、文件、文件夹。3、部门的层级 

### 装饰器模式（Decorator Pattern）

​	装饰器模式（Decorator Pattern）允许**向一个现有的对象添加新的功能**，**同时又不改变其结构**。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

​	包装原有的类，并在保持类方法签名完整性的前提下，提供额外功能。（不改变类的本质添加功能。）

**用法：**动态地给一个对象添加一些额外的指责。**（灵活的动态添加功能而不是生成子类）**

**优点：**装饰类和被装饰类可以独立发展，不会**相互耦合，**装饰模式是继承的一个替代模式，**装饰模式可以动态扩展一个实现类的功能。**

**缺点：**多层装饰比较复杂。**（注意复杂度！）**

**应用：**1、扩展一个类的功能。2、动态增加功能，动态撤销。（丝毫不影响原本），3、扩展或重写父类的方法，但不影响其本身。

**注意：**

1. 意为对类/对象的功能的添加，但是不改变他的结构。
2. 使用这种模式也要注意和继承的分开和关系

lol

一个容器-->可以容纳实现学习技能-->不同人不同角色扮演学习/掌握/使用不同技能



### 外观模式（Facade Pattern）

​	外观模式（Facade Pattern）**隐藏系统的复杂性**，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向**现有的系统添加一个接口，来隐藏系统的复杂性**。

​	单一的类提供客户端**请求的简化方法**和对**现有系统类方法的委托调用**。

**用法：**如何定义系统的入口**（在客户端和系统之间加一层复杂度，所以这一层的逻辑、调用顺序、依赖关系要处理好）**，使得子系统中的一组接口与客户端 提供一个一致的界面，定义一个高层接口，使得这一子系统更容易使用。（简化系统和客户端之间的复杂联系，及接口）；

**优点：** 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。

**缺点：**不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。

**应用：**1、后端服务和前台之间加一个UI层进行访问、对接、调用、安全。2、为复杂的模块或子系统提供外界访问的模块。 3、子系统相对独立。 4、预防低水平人员带来的风险。

**注意：**在层次化结构中，可以使用外观模式定义系统中每一层的入口。



### 享元模式（Flyweight Pattern）

​	享元模式（Flyweight Pattern）主要用**于减少创建对象的数量**，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。（先重用先有对象，如果没有则创建。）

**用法：**运用单例或者共享一个类/接口，等方法生成一个共享元。从而达到重复使用、减少内存、对象数量等目的。（用唯一标识码判断（如HashMap），如果在内存中有，则返回这个唯一标识码所标识的对象。）

**优点：**大大减少对象的创建，降低系统的内存，使效率提高。

**缺点：**提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。

**应用：**1、数据库链接池。2、需要多次调用的实例/单例。如JQ。

**注意：**

1. **在单线程中也要注意变量、作用域、函数等问题**
2. **注意划分外部状态和内部状态，否则可能会引起线程安全问题。**
3. 这些类必须有一个工厂对象加以控制。





### 代理模式（Proxy Pattern）

​	在代理模式（Proxy Pattern）中，**一个类代表另一个类的功能**。这种类型的设计模式属于结构型模式。

​	在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。

**用法：**在类和实现之间加一层代理的中间层。对类的访问加上控制、权限等。**（仅负责代理分发控制不负责实现）**

**优点：** 1、职责清晰。 2、高扩展性。 **3、智能化。**

**缺点：** 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

**应用：**1、nginx代理转发（不知道算不算）。2、类接口的代理，来控制接口访问/访问安全性。接口转发分发等。

**使用场景：**按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。

**注意：**1、与适配器模式的区别：适配器改变对象的接口，而代理不能改变代理类的接口。



## 行为型模式

> 这些设计模式特别关注对象之间的通信。	

### 责任链模式

​	责任链模式（Chain of Responsibility Pattern）为**请求创建了一个接收者对象的链**。这种模式给予请求的类型，**对请求的发送者和接收者进行解耦**。这种类型的设计模式属于行为型模式。

​	在这种模式中，通常**每个接收者都包含对另一个接收者的引用**。如果**一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者**，依此类推。

**用法：**把请求者和接收者耦合在一起，把多个对象链接成一条链，让接收者沿着一条责任链找到能够处理请求者的对象为止。

**优点：** 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。

**缺点：** 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。

**应用：** 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。

**注意：**1、请求者和接收者的各个耦合关系。2、责任链（不同接收者）的处理。3、在应用（如WEB）中的接口问题

### 命令模式

​	命令模式（Command Pattern）是一种**数据驱动的设计模式**，它属于行为型模式。**请求以命令的形式包裹在对象中，并传给调用对象**。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。（处理命令，命令到合适的对象进行处理）

**用法：**把请求（执行的方法/方式/过程）封装成一个对象。来命令服务器（工具类）来进行对应的请求/参数处理/操作（顺序：调用者→接受者→命令。）。同理，反之亦然。

**优点：** 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。

**缺点：**使用命令模式可能会导致某些系统有过多的具体命令类。

**应用：**1、行为请求者与行为实现者的紧密耦合变成松耦合。（从而降低系统的耦合）2、行为操作如：记录/撤销/重做/事务。

**注意：**

### 解释器模式（Interpreter Pattern）

​	解释器模式（Interpreter Pattern）提供了评估**语言的语法或表达式的方式**，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。

**用法：**定义一个解析器，用来标识来解析语言中的句子。

**优点：** 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。

**缺点：** 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。

### 迭代器模式（Iterator Pattern）

​	迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

**优点：** 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。

**缺点：**由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。

### 中介者模式（Mediator Pattern）

​	中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。

**优点：** 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。

**缺点：**中介者会庞大，变得复杂难以维护。

### 备忘录模式（Memento Pattern）

​	备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。

**优点：** 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。

**缺点：**消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。

### 观察者模式（Observer Pattern）

​	当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。

**优点：** 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。

**缺点：** 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

### 状态模式（State Pattern）

​	在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。

在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。

**优点：** 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。

**缺点：** 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。

### 空对象模式（Null Object Pattern）

​	在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。

在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。



### 策略模式

​	在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。

在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。

**优点：** 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。

**缺点：** 1、策略类会增多。 2、所有策略类都需要对外暴露。

### 模板模式

​	在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。

**优点：** 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。

**缺点：**每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。

### 访问者模式 

​	在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。

**优点：** 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。

**缺点：** 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。

## J2EE模式

> 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。

### MVC 模式( Model-View-Controller)

​	MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。

- **Model（模型）** - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。

- **View（视图）** - 视图代表模型包含的数据的可视化。

- **Controller（控制器）** - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。



### 业务代表模式	（Business Delegate Pattern）

​	业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。

- **客户端（Client）** - 表示层代码可以是 JSP、servlet 或 UI java 代码。
- **业务代表（Business Delegate）** - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。
- **查询服务（LookUp Service）** - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。
- **业务服务（Business Service）** - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。





### 组合实体模式（Composite Entity Pattern）

​	组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。

- **组合实体（Composite Entity）** - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。
- **粗粒度对象（Coarse-Grained Object）** - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。
- **依赖对象（Dependent Object）** - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。
- **策略（Strategies）** - 策略表示如何实现组合实体。

### 数据访问对象模式（Data Access Object Pattern）

​	数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。

- **数据访问对象接口（Data Access Object Interface）** - 该接口定义了在一个模型对象上要执行的标准操作。
- **数据访问对象实体类（Data Access Object concrete class）** - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。
- **模型对象/数值对象（Model Object/Value Object）** - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。

### 前端控制器模式（Front Controller Pattern）

​	前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。

- **前端控制器（Front Controller）** - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。
- **调度器（Dispatcher）** - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。
- **视图（View）** - 视图是为请求而创建的对象。

### 拦截过滤器模式（Intercepting Filter Pattern）

​	拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。

- **过滤器（Filter）** - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。

- **过滤器链（Filter Chain）** - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。

- **Target** - Target 对象是请求处理程序。

- **过滤管理器（Filter Manager）** - 过滤管理器管理过滤器和过滤器链。

- **客户端（Client）** - Client 是向 Target 对象发送请求的对象。


### 服务定位器模式（Service Locator Pattern）

​	服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。

- **服务（Service）** - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。
- **Context / 初始的 Context** - JNDI Context 带有对要查找的服务的引用。
- **服务定位器（Service Locator）** - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。
- **缓存（Cache）** - 缓存存储服务的引用，以便复用它们。
- **客户端（Client）** - Client 是通过 ServiceLocator 调用服务的对象。

### 传输对象模式（Transfer Object Pattern）

​	传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。

- **业务对象（Business Object）** - 为传输对象填充数据的业务服务。
- **传输对象（Transfer Object）** - 简单的 POJO，只有设置/获取属性的方法。
- **客户端（Client）** - 客户端可以发送请求或者发送传输对象到业务对象。