读完菜鸟教程里面的设计模式的概念和理解，学到了一些以前没有学到的，复习了用过的以及加深了印象和理解，感觉很有用就总结一下分享一下。[链接](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)

**~~侵删请issues联系~~**

------

<div align=center>
  <img src="..\assets\img\the-relationship-between-design-patterns.jpg" alt="关系图" />
</div>

# 设计模式的六大原则

**1、开闭原则（Open Close Principle）**

开闭原则的意思是：<font color=#dc3545>**对扩展开放，对修改关闭**</font>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是**为了使程序的扩展性好，易于维护和升级**。想要达到这样的效果，我们需要**使用接口和抽象类**，后面的具体设计中我们会提到这点。

**2、里氏代换原则（Liskov Substitution Principle）**

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，**任何基类可以出现的地方，子类一定可以出现**。LSP 是继承**复用**的基石，只有当派生类可以**替换**掉基类，且**软件单位的功能不受到影响**时，基类才能真正被复用，而派生类也能够在基类的基础上**增加新的行为**。里氏代换原则是对开闭原则的补充。实现开闭原则的**关键步骤**就是抽象化，而基类与子类的**继承关系**就是**抽象化的具体实现**，所以<font color=#dc3545>**里氏代换原则是对实现抽象化的具体步骤的规范**</font>。

**3、依赖倒转原则（Dependence Inversion Principle）**

这个原则是开闭原则的基础，具体内容：<font color=#dc3545 >**针对接口编程，依赖于抽象而不依赖于具体。**</font>

**4、接口隔离原则（Interface Segregation Principle）**

这个原则的意思是：**使用多个隔离的接口，比使用单个接口要好**。它还有另外一个意思是：**降低类之间的耦合度**。由此可见，其实设计模式就是<font color=#dc3545>**从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合**</font>。

**5、迪米特法则，又称最少知道原则（Demeter Principle）**

最少知道原则是指：**一个实体应当尽量少地与其他实体之间发生相互作用**，使得<font color=#dc3545>**系统功能模块相对独立**</font>。

**6、合成复用原则（Composite Reuse Principle）**

合成复用原则是指：<font color=#dc3545>**尽量使用合成/聚合的方式，而不是使用继承**</font>。



# 设计模式 Design Patterns（33种）

## 创建型模式

> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

### 工厂模式（Factory Pattern）

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过**使用一个共同的接口来指向新创建的对象**。

**做法：**定义一个创建对象的接口，子类去决定实例化哪一个工厂类。（实例的创建延迟到子类执行）；

**优点：**1、一个调用者想创建一个对象，只要**知其名称就可以了**。2、扩展性高，如果想增加一个产品，只有扩展一个工厂类就可以。3、屏蔽产品的具体实现，调用者只关心产品的接口。

**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

**应用实例：** 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

**注意：**

- 任何需要生成复杂对象的地方，都可以用。
- 复杂对象适合使用工厂模式，而简单的直接new就行（直接调用）
- 不要盲目使用工厂模式，添加系统复杂度。

**一、一句话概括工厂模式**

-  **简单工厂**：一个工厂类，一个产品抽象类。
-  **工厂方法**：多个工厂类，一个产品抽象类。
-  **抽象工厂**：多个工厂类，多个产品抽象类。

**二、生活中的工厂模式**

-  简单工厂类：一个麦当劳店，可以生产多种汉堡。
-  工厂方法类：一个麦当劳店，可以生产多种汉堡。一个肯德基店，也可以生产多种汉堡。
-  抽象工厂类：百胜餐饮集团下有肯德基和百事公司，肯德基生产汉堡，百事公司生成百事可乐。



```

```

### 抽象工厂模式（Abstract Factory Pattern）

​	抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。

​	在抽象工厂模式中，**接口是负责创建一个相关对象的工厂**（本身就是工厂），**不需要显式指定它们的类**。每个生成的工厂都能按照工厂模式提供对象。

 **做法：（在一个工厂里聚合多个同类产品。）** 创建和实例接口的实体类。创建一个抽象工厂类，让实体类成为抽象工厂AbstracFactory的扩展。通过抽象工厂定义/接口创建工厂的创造器/生成器。

**优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

**缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

**实例应用：**抽象工厂能够同时生产鼠标、键盘（父级工厂提供2个接口一个是生产鼠标，另一个是生产键盘），戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。

**注意：**

- **产品族难扩展，产品等级易扩展。**
- 如何抽象产品和具体实现，注意产品族的扩展和维护。划分等级的时候分清楚产品族的关系

### 单例模式（Singleton Pattern）

​	这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了**一种访问其唯一的对象的方式**，可以直接访问，不需要实例化该类的对象。（最简单的设计模式）

**做法：**定义一个类，保证全局只有一个实例，并提供一个全局的访问接口。

**优点：** 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。

**缺点：**没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

**应用：**1、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接。2、全局类的实例化然后多次调用。

**注意：**

- 单例类只能有一个实例。
- 单例类必须自己创建自己的唯一实例。
- 单例类必须给所有其他对象提供这一实例。



### 建造者模式（Builder Pattern）

建造者模式（Builder Pattern）使用**多个简单的对象一步一步构建成一个复杂的对象**。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

**做法：**将构建和表现分离 --> 通过不同参数或者不同配置，生成或混入不同方法（表现或结构），最后创建成一个新的实例（不同的表示方式）。

**优点：** 1、建造者独立，易扩展。 2、便于控制细节风险。

**缺点：** 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。

**应用：**1、一般使用在一些基本部件不会变，而其组合经常变化的时候。2、组件化开发  -->团队中模块化分工/管理。3、需要生成的对象内部属性本身相互依赖。4、需要生成的对象具有复杂的内部结构。

**注意：**

- **将一个复杂的构建过程与其表示相分离**

- 建造者模式更关注与零件装配的顺序（实例组装的过程/逻辑的过程）；

- 如何划分每一个零件（组件/方法等）；

- 设计过程中注意：建造者、监工、使用者（客户）之间的关系。


### 原型模式（Prototype Pattern）

​	原型模式（Prototype Pattern）是用于**创建重复的对象**，同时又能**保证性能**。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	这种模式是实现了一个原型接口，该接口用于创建**当前对象的克隆**。当直接创建对象的代价**比较大**时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

**做法：**用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。（关键在于：1、如何深度克隆。2、隔离类对象的使用者和具体类型（具体类型容易变化）之间的耦合关系。

**优点：** 1、性能提高。 2、逃避构造函数的约束。

**缺点：** 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。

**应用：**

1. **类的初始化**、重复创建的对象（类）。克隆类/对象。
2. **资源优化场景**
3. **一个对象多个修改者的场景**
4. 通过 new 产生一个对象需要**非常繁琐的数据准备或访问权限**，则可以使用原型模式。
5. 一个对象需要提供给其他对象访问，而且**各个调用者可能都需要修改其值时**，可以考虑使用原型模式拷贝多个对象供调用者使用。
6. 逃避构造函数的约束

**注意：**

- 原型链通过拷贝对象来生成一个新对象。（js中newObj继承prototype链上的方法亦如此）
- 一个系统应该独立于它的产品创建，构成和表示。
- 为了避免创建一个与产品类层次平行的工厂类层次时
- 当一个类的实例只能有几个不同状态组合中的一种时，注意其实例管理、耦合、变量等关系。



## 结构型模式

> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。

### 适配器模式（Adapter Pattern）

​	适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

**用来做兼容操作的模式。**

**做法：**（一般可以选择惰性函数）在类的初始化/类的调用，之前**检查兼容**，使其能够选择正确**兼容的方式工作**。

**优点：** 1、可以让任何**两个没有关联的类**一起运行。 2、提高了**类的复用**。 3、增加了类的透明度。 4、灵活性好。

**缺点：** 1、**过多地使用适配器，会让系统非常零乱，不易整体进行把握。**比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。

**应用：**1、接口/系统/版本/等兼容。2、业务逻辑的适配，如权限/路由/订单数据，等

### 桥接模式

### 过滤器模式

### 组合模式

### 装饰器模式

### 外观模式

### 享元模式

### 代理模式

## 行为型模式

> 这些设计模式特别关注对象之间的通信。	

### 责任链模式

### 命令模式

### 解释器模式

### 迭代器模式

### 中介者模式

### 备忘录模式

### 观察者模式

### 状态模式

### 空对象模式

### 策略模式

### 模板模式

### 访问者模式

## J2EE模式

> 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。

### MVC 模式

### 业务代表模式

### 组合实体模式

### 数据访问对象模式

### 前端控制器模式

### 拦截过滤器模式

### 服务定位器模式

### 传输对象模式
