读完菜鸟教程里面的设计模式的概念和理解，学到了一些以前没有学到的，复习了用过的以及加深了印象和理解，感觉很有用就总结一下分享一下。[链接](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)

------

<div align=center>
  <img src="..\assets\img\the-relationship-between-design-patterns.jpg" alt="关系图" />
</div>

# 设计模式的六大原则

**1、开闭原则（Open Close Principle）**

开闭原则的意思是：<font color=#dc3545>**对扩展开放，对修改关闭**</font>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是**为了使程序的扩展性好，易于维护和升级**。想要达到这样的效果，我们需要**使用接口和抽象类**，后面的具体设计中我们会提到这点。

**2、里氏代换原则（Liskov Substitution Principle）**

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，**任何基类可以出现的地方，子类一定可以出现**。LSP 是继承**复用**的基石，只有当派生类可以**替换**掉基类，且**软件单位的功能不受到影响**时，基类才能真正被复用，而派生类也能够在基类的基础上**增加新的行为**。里氏代换原则是对开闭原则的补充。实现开闭原则的**关键步骤**就是抽象化，而基类与子类的**继承关系**就是**抽象化的具体实现**，所以<font color=#dc3545>**里氏代换原则是对实现抽象化的具体步骤的规范**</font>。

**3、依赖倒转原则（Dependence Inversion Principle）**

这个原则是开闭原则的基础，具体内容：<font color=#dc3545 >**针对接口编程，依赖于抽象而不依赖于具体。**</font>

**4、接口隔离原则（Interface Segregation Principle）**

这个原则的意思是：**使用多个隔离的接口，比使用单个接口要好**。它还有另外一个意思是：**降低类之间的耦合度**。由此可见，其实设计模式就是<font color=#dc3545>**从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合**</font>。

**5、迪米特法则，又称最少知道原则（Demeter Principle）**

最少知道原则是指：**一个实体应当尽量少地与其他实体之间发生相互作用**，使得<font color=#dc3545>**系统功能模块相对独立**</font>。

**6、合成复用原则（Composite Reuse Principle）**

合成复用原则是指：<font color=#dc3545>**尽量使用合成/聚合的方式，而不是使用继承**</font>。



# 设计模式 Design Patterns（33种）

## 创建型模式

> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

### 工厂模式（Factory Pattern）

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过**使用一个共同的接口来指向新创建的对象**。

**做法：**定义一个创建对象的接口，子类去决定实例化哪一个工厂类。（实例的创建延迟到子类执行）；

**优点：**1、一个调用者想创建一个对象，只要**知其名称就可以了**。2、扩展性高，如果想增加一个产品，只有扩展一个工厂类就可以。3、屏蔽产品的具体实现，调用者只关心产品的接口。

**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

**应用实例：** 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

**注意：**

- 任何需要生成复杂对象的地方，都可以用。
- 复杂对象适合使用工厂模式，而简单的直接new就行（直接调用）
- 不要盲目使用工厂模式，添加系统复杂度。

**一、一句话概括工厂模式**

-  **简单工厂**：一个工厂类，一个产品抽象类。
-  **工厂方法**：多个工厂类，一个产品抽象类。
-  **抽象工厂**：多个工厂类，多个产品抽象类。

**二、生活中的工厂模式**

-  简单工厂类：一个麦当劳店，可以生产多种汉堡。
-  工厂方法类：一个麦当劳店，可以生产多种汉堡。一个肯德基店，也可以生产多种汉堡。
-  抽象工厂类：百胜餐饮集团下有肯德基和百事公司，肯德基生产汉堡，百事公司生成百事可乐。

### 抽象工厂模式（Abstract Factory Pattern）

​	抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。

​	在抽象工厂模式中，**接口是负责创建一个相关对象的工厂**（本身就是工厂），**不需要显式指定它们的类**。每个生成的工厂都能按照工厂模式提供对象。

 **做法：（在一个工厂里聚合多个同类产品。）** 创建和实例接口的实体类。创建一个抽象工厂类，让实体类成为抽象工厂AbstracFactory的扩展。通过抽象工厂定义/接口创建工厂的创造器/生成器。

**优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

**缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

**实例应用：**抽象工厂能够同时生产鼠标、键盘（父级工厂提供2个接口一个是生产鼠标，另一个是生产键盘），戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。

**注意：**

- **产品族难扩展，产品等级易扩展。**
- 如何抽象产品和具体实现，注意产品族的扩展和维护。划分等级的时候分清楚产品族的关系

### 单例模式（Singleton Pattern）

​	这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了**一种访问其唯一的对象的方式**，可以直接访问，不需要实例化该类的对象。（最简单的设计模式）

**做法：**定义一个类，保证全局只有一个实例，并提供一个全局的访问接口。

**优点：** 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。

**缺点：**没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

**应用：**1、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接。2、全局类的实例化然后多次调用。

**注意：**

- 单例类只能有一个实例。
- 单例类必须自己创建自己的唯一实例。
- 单例类必须给所有其他对象提供这一实例。



### 建造者模式（Builder Pattern）

建造者模式（Builder Pattern）使用**多个简单的对象一步一步构建成一个复杂的对象**。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

**做法：**将构建和表现分离 --> 通过不同参数或者不同配置，生成或混入不同方法（表现或结构），最后创建成一个新的实例（不同的表示方式）。

**优点：** 1、建造者独立，易扩展。 2、便于控制细节风险。

**缺点：** 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。

**应用：**1、一般使用在一些基本部件不会变，而其组合经常变化的时候。2、组件化开发  -->团队中模块化分工/管理。3、需要生成的对象内部属性本身相互依赖。4、需要生成的对象具有复杂的内部结构。

**注意：**

- **将一个复杂的构建过程与其表示相分离**

- 建造者模式更关注与零件装配的顺序（实例组装的过程/逻辑的过程）；

- 如何划分每一个零件（组件/方法等）；

- 设计过程中注意：建造者、监工、使用者（客户）之间的关系。


### 原型模式（Prototype Pattern）

​	原型模式（Prototype Pattern）是用于**创建重复的对象**，同时又能**保证性能**。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

​	这种模式是实现了一个原型接口，该接口用于创建**当前对象的克隆**。当直接创建对象的代价**比较大**时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

**做法：**用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。（关键在于：1、如何深度克隆。2、隔离类对象的使用者和具体类型（具体类型容易变化）之间的耦合关系。

**优点：** 1、性能提高。 2、逃避构造函数的约束。

**缺点：** 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。

**应用：**

1. **类的初始化**、重复创建的对象（类）。克隆类/对象。
2. **资源优化场景**
3. **一个对象多个修改者的场景**
4. 通过 new 产生一个对象需要**非常繁琐的数据准备或访问权限**，则可以使用原型模式。
5. 一个对象需要提供给其他对象访问，而且**各个调用者可能都需要修改其值时**，可以考虑使用原型模式拷贝多个对象供调用者使用。
6. 逃避构造函数的约束

**注意：**

- 原型链通过拷贝对象来生成一个新对象。（js中newObj继承prototype链上的方法亦如此）
- 一个系统应该独立于它的产品创建，构成和表示。
- 为了避免创建一个与产品类层次平行的工厂类层次时
- 当一个类的实例只能有几个不同状态组合中的一种时，注意其实例管理、耦合、变量等关系。



## 结构型模式

> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。

### 适配器模式（Adapter Pattern）

​	适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

**用来做兼容操作的模式。**

**做法：**（一般可以选择惰性函数）在类的初始化/类的调用，之前**检查兼容**，使其能够选择正确**兼容的方式工作**。

**优点：** 1、可以让任何**两个没有关联的类**一起运行。 2、提高了**类的复用**。 3、增加了类的透明度。 4、灵活性好。

**缺点：** 1、**过多地使用适配器，会让系统非常零乱，不易整体进行把握。**比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。

**应用：**1、接口/系统/版本/等兼容。2、业务逻辑的适配，如权限/路由/订单数据，等

### 桥接模式（Bridge Pattern）

​	桥接（Bridge）是用于把**抽象化与实现化解耦**，使得二者可以**独立变化**。这种类型的设计模式属于结构型模式，它通过提供**抽象化和实现化之间的桥接结构，来实现二者的解耦**。

​	这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。

​	**将抽象部分与实现部分分离，使它们都可以独立的变化。**

**用法：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。（抽象类依赖实现类）

**优点：** 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。

**缺点：**桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。

**应用：**1、解决多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。2、经纬度的独立变化。

### 过滤器模式（Filter Pattern）

​	过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过**逻辑运算以解耦的方式把它们连接起来**。这种类型的设计模式属于结构型模式，它**结合多个标准来获得单一标准**。

​	**用法：**创建一个类和接口的定义，以及实现该接口的实体类。然后根据定义的标准来对对象的过滤。

### 组合模式（Composite Pattern）

​	组合模式（Composite Pattern），又叫部分整体模式，是用于**把一组相似的对象当作一个单一的对象**。组合模式依据**树形结构**来组合对象，用来**表示部分以及整体层次**。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

​	这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

**用法：**将对象组合成树形结构以表示”部分-整体"的层次结构。处理单个对象和组合对象的使用的一致性。

**优点：** 1、高层模块调用简单。 2、节点自由增加。

**缺点：**在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。

**应用：**1、树枝和叶子实现统一接口（由树枝内部组合这些接口）。2、部分、整体的场景，如菜单、文件、文件夹。3、部门的层级 

### 装饰器模式（Decorator Pattern）

​	装饰器模式（Decorator Pattern）允许**向一个现有的对象添加新的功能**，**同时又不改变其结构**。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

​	包装原有的类，并在保持类方法签名完整性的前提下，提供额外功能。（不改变类的本质添加功能。）

**用法：**动态地给一个对象添加一些额外的指责。**（灵活的动态添加功能而不是生成子类）**

**优点：**装饰类和被装饰类可以独立发展，不会**相互耦合，**装饰模式是继承的一个替代模式，**装饰模式可以动态扩展一个实现类的功能。**

**缺点：**多层装饰比较复杂。**（注意复杂度！）**

**应用：**1、扩展一个类的功能。2、动态增加功能，动态撤销。（丝毫不影响原本），3、扩展或重写父类的方法，但不影响其本身。

**注意：**

1. 意为对类/对象的功能的添加，但是不改变他的结构。
2. 使用这种模式也要注意和继承的分开和关系

lol

一个容器-->可以容纳实现学习技能-->不同人不同角色扮演学习/掌握/使用不同技能



### 外观模式（Facade Pattern）

​	外观模式（Facade Pattern）**隐藏系统的复杂性**，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向**现有的系统添加一个接口，来隐藏系统的复杂性**。

​	单一的类提供客户端**请求的简化方法**和对**现有系统类方法的委托调用**。

**用法：**如何定义系统的入口**（在客户端和系统之间加一层复杂度，所以这一层的逻辑、调用顺序、依赖关系要处理好）**，使得子系统中的一组接口与客户端 提供一个一致的界面，定义一个高层接口，使得这一子系统更容易使用。（简化系统和客户端之间的复杂联系，及接口）；

**优点：** 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。

**缺点：**不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。

**应用：**1、后端服务和前台之间加一个UI层进行访问、对接、调用、安全。2、为复杂的模块或子系统提供外界访问的模块。 3、子系统相对独立。 4、预防低水平人员带来的风险。

**注意：**在层次化结构中，可以使用外观模式定义系统中每一层的入口。



### 享元模式（Flyweight Pattern）

​	享元模式（Flyweight Pattern）主要用**于减少创建对象的数量**，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。（先重用先有对象，如果没有则创建。）

**用法：**运用单例或者共享一个类/接口，等方法生成一个共享元。从而达到重复使用、减少内存、对象数量等目的。（用唯一标识码判断（如HashMap），如果在内存中有，则返回这个唯一标识码所标识的对象。）

**优点：**大大减少对象的创建，降低系统的内存，使效率提高。

**缺点：**提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。

**应用：**1、数据库链接池。2、需要多次调用的实例/单例。如JQ。

**注意：**

1. **在单线程中也要注意变量、作用域、函数等问题**
2. **注意划分外部状态和内部状态，否则可能会引起线程安全问题。**
3. 这些类必须有一个工厂对象加以控制。





### 代理模式（Proxy Pattern）

​	在代理模式（Proxy Pattern）中，**一个类代表另一个类的功能**。这种类型的设计模式属于结构型模式。

​	在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。

**用法：**在类和实现之间加一层代理的中间层。对类的访问加上控制、权限等。**（仅负责代理分发控制不负责实现）**

**优点：** 1、职责清晰。 2、高扩展性。 **3、智能化。**

**缺点：** 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

**应用：**1、nginx代理转发（不知道算不算）。2、类接口的代理，来控制接口访问/访问安全性。接口转发分发等。

**使用场景：**按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。

**注意：**1、与适配器模式的区别：适配器改变对象的接口，而代理不能改变代理类的接口。



## 行为型模式

> 这些设计模式特别关注对象之间的通信。	

### 责任链模式

​	责任链模式（Chain of Responsibility Pattern）为**请求创建了一个接收者对象的链**。这种模式给予请求的类型，**对请求的发送者和接收者进行解耦**。这种类型的设计模式属于行为型模式。

​	在这种模式中，通常**每个接收者都包含对另一个接收者的引用**。如果**一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者**，依此类推。

**用法：**把请求者和接收者耦合在一起，把多个对象链接成一条链，让接收者沿着一条责任链找到能够处理请求者的对象为止。

**优点：** 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。

**缺点：** 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。

**应用：** 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。

**注意：**1、请求者和接收者的各个耦合关系。2、责任链（不同接收者）的处理。3、在应用（如WEB）中的接口问题

### 命令模式

​	命令模式（Command Pattern）是一种**数据驱动的设计模式**，它属于行为型模式。**请求以命令的形式包裹在对象中，并传给调用对象**。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。（处理命令，命令到合适的对象进行处理）

**用法：**把请求（执行的方法/方式/过程）封装成一个对象。来命令服务器（工具类）来进行对应的请求/参数处理/操作（顺序：调用者→接受者→命令。）。同理，反之亦然。

**优点：** 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。

**缺点：**使用命令模式可能会导致某些系统有过多的具体命令类。

**应用：**1、行为请求者与行为实现者的紧密耦合变成松耦合。（从而降低系统的耦合）2、行为操作如：记录/撤销/重做/事务。

**注意：**

### 解释器模式

### 迭代器模式

### 中介者模式

### 备忘录模式

### 观察者模式

### 状态模式

### 空对象模式

### 策略模式

### 模板模式

### 访问者模式

## J2EE模式

> 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。

### MVC 模式

### 业务代表模式

### 组合实体模式

### 数据访问对象模式

### 前端控制器模式

### 拦截过滤器模式

### 服务定位器模式

### 传输对象模式
